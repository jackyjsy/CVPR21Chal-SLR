<html>
<head>
<title>ImageStack</title>

<style type="text/css">

body {
font-family: georgia;
}

td {
line-height: 140%;
}

h3 {
font-variant:small-caps;
}

h1 {
font-variant:small-caps;
line-height:1.2;
}

a {
color:222288;
text-decoration:none;
}

a:hover {
text-decoration:underline;
}


</style>

</head>
<body bgcolor=dddddd>
<center>

<br><br>
<table width=850 bgcolor=ffffff border=30 bordercolor=ffffff rules=none frame=border>
<tr><td>
<center><H2>ImageStack Operation Listing</H2></center>
Operations available are:
<a href="#abs">-abs</a> <a href="#add">-add</a> <a href="#adjoin">-adjoin</a> <a href="#affinewarp">-affinewarp</a> <a href="#align">-align</a> <a href="#alignframes">-alignframes</a> <a href="#assemblehdr">-assemblehdr</a> <a href="#bidirectionalsimilarity">-bidirectionalsimilarity</a> <a href="#bilateral">-bilateral</a> <a href="#bilateralsharpen">-bilateralsharpen</a> <a href="#chromablur">-chromablur</a> <a href="#circularfilter">-circularfilter</a> <a href="#clamp">-clamp</a> <a href="#colorconvert">-colorconvert</a> <a href="#colormatrix">-colormatrix</a> <a href="#complexconjugate">-complexconjugate</a> <a href="#complexdivide">-complexdivide</a> <a href="#compleximag">-compleximag</a> <a href="#complexmagnitude">-complexmagnitude</a> <a href="#complexmultiply">-complexmultiply</a> <a href="#complexphase">-complexphase</a> <a href="#complexreal">-complexreal</a> <a href="#composite">-composite</a> <a href="#convolve">-convolve</a> <a href="#createtmp">-createtmp</a> <a href="#crop">-crop</a> <a href="#daubechies">-daubechies</a> <a href="#dct">-dct</a> <a href="#deconvolve">-deconvolve</a> <a href="#deinterleave">-deinterleave</a> <a href="#demosaic">-demosaic</a> <a href="#denan">-denan</a> <a href="#dimensionreduction">-dimensionreduction</a> <a href="#dimensions">-dimensions</a> <a href="#display">-display</a> <a href="#divide">-divide</a> <a href="#downsample">-downsample</a> <a href="#dup">-dup</a> <a href="#equalize">-equalize</a> <a href="#eval">-eval</a> <a href="#evalchannels">-evalchannels</a> <a href="#exp">-exp</a> <a href="#fastblur">-fastblur</a> <a href="#fft">-fft</a> <a href="#fftconvolve">-fftconvolve</a> <a href="#fftdeconvolve">-fftdeconvolve</a> <a href="#fftpoisson">-fftpoisson</a> <a href="#flip">-flip</a> <a href="#fprintf">-fprintf</a> <a href="#frametiles">-frametiles</a> <a href="#gamma">-gamma</a> <a href="#gaussianblur">-gaussianblur</a> <a href="#gausstransform">-gausstransform</a> <a href="#gradient">-gradient</a> <a href="#gradmag">-gradmag</a> <a href="#haar">-haar</a> <a href="#help">-help</a> <a href="#histogram">-histogram</a> <a href="#histogrammatch">-histogrammatch</a> <a href="#ifft">-ifft</a> <a href="#inpaint">-inpaint</a> <a href="#integrate">-integrate</a> <a href="#interleave">-interleave</a> <a href="#inversedaubechies">-inversedaubechies</a> <a href="#inversehaar">-inversehaar</a> <a href="#jointbilateral">-jointbilateral</a> <a href="#kmeans">-kmeans</a> <a href="#lahbpcg">-lahbpcg</a> <a href="#lanczosblur">-lanczosblur</a> <a href="#lffocalstack">-lffocalstack</a> <a href="#lfpoint">-lfpoint</a> <a href="#lfwarp">-lfwarp</a> <a href="#load">-load</a> <a href="#loadarray">-loadarray</a> <a href="#loadblock">-loadblock</a> <a href="#loadframes">-loadframes</a> <a href="#loadpanorama">-loadpanorama</a> <a href="#localmaxima">-localmaxima</a> <a href="#log">-log</a> <a href="#loop">-loop</a> <a href="#max">-max</a> <a href="#medianfilter">-medianfilter</a> <a href="#min">-min</a> <a href="#mod">-mod</a> <a href="#multiply">-multiply</a> <a href="#nlmeans">-nlmeans</a> <a href="#noise">-noise</a> <a href="#normalize">-normalize</a> <a href="#offset">-offset</a> <a href="#panoramabackground">-panoramabackground</a> <a href="#paste">-paste</a> <a href="#patchmatch">-patchmatch</a> <a href="#patchpca">-patchpca</a> <a href="#pause">-pause</a> <a href="#pca">-pca</a> <a href="#percentilefilter">-percentilefilter</a> <a href="#plot">-plot</a> <a href="#poisson">-poisson</a> <a href="#pop">-pop</a> <a href="#printf">-printf</a> <a href="#pull">-pull</a> <a href="#push">-push</a> <a href="#quantize">-quantize</a> <a href="#realcomplex">-realcomplex</a> <a href="#receive">-receive</a> <a href="#rectfilter">-rectfilter</a> <a href="#resample">-resample</a> <a href="#reshape">-reshape</a> <a href="#rotate">-rotate</a> <a href="#save">-save</a> <a href="#savearray">-savearray</a> <a href="#saveblock">-saveblock</a> <a href="#saveframes">-saveframes</a> <a href="#scale">-scale</a> <a href="#send">-send</a> <a href="#shuffle">-shuffle</a> <a href="#sinugram">-sinugram</a> <a href="#sort">-sort</a> <a href="#statistics">-statistics</a> <a href="#subsample">-subsample</a> <a href="#subtract">-subtract</a> <a href="#threshold">-threshold</a> <a href="#tile">-tile</a> <a href="#tileframes">-tileframes</a> <a href="#time">-time</a> <a href="#translate">-translate</a> <a href="#transpose">-transpose</a> <a href="#upsample">-upsample</a> <a href="#warp">-warp</a> <a href="#wls">-wls</a> 
<p><a name="abs"><h3>abs</h3></a>
<p>
<p>
<p>
-abs takes the absolute value of the current image.
<p>
Usage: ImageStack -load a.tga -load b.tga -subtract -abs -save diff.tga
<p>
<p>
<p><a name="add"><h3>add</h3></a>
<p>
<p>
<p>
-add adds the second image in the stack to the top image in the stack.
<p>
Usage: ImageStack -load a.tga -load b.tga -add -save out.tga.
<p>
<p><a name="adjoin"><h3>adjoin</h3></a>
<p>
<p>
<p>
-adjoin takes 'x', 'y', 't', or 'c' as the argument, and joins the top two
images along that dimension. The images must match in the other dimensions.
<p>
Usage: ImageStack -load a.tga -load b.tga -adjoin x -save ab.tga
<p>
<p>
<p><a name="affinewarp"><h3>affinewarp</h3></a>
<p>
<p>
<p>
-affinewarp takes a 2x3 matrix in row major order, and performs that affine warp
on the image.
<p>
Usage: ImageStack -load a.jpg -affinewarp 0.9 0.1 0 0.1 0.9 0 -save out.jpg
<p>
<p>
<p><a name="align"><h3>align</h3></a>
<p>
<p>
-align warps the top image on the stack to match the second image on the
stack. align takes one argument, which must be "translate", "similarity", 
"affine", "perspective", or "rigid" and constrains the warp to be of that
type.
<p>
Usage: ImageStack -load a.jpg -load b.jpg -align similarity \
                  -add -save ab.jpg
<p>
<p>
<p><a name="alignframes"><h3>alignframes</h3></a>
<p>
<p>
<p>
<p><a name="assemblehdr"><h3>assemblehdr</h3></a>
<p>
<p>
-assemblehdr takes a volume in which each frame is a linear luminance image
taken at a different exposure, and compiles them all into a single HDR image,
gracefully handling oversaturated regions.
<p>
If exposure values are known, they can be given in increasing frame order.
Otherwise, assemblehdr attempts to discover the exposure ratios itself, which
may fail if there are very few pixels that are properly imaged in multiple
frames. For best results, load the frames in either increasing or decreasing
exposure order.
<p>
Usage: ImageStack -loadframes input*.jpg -gamma 0.45 -assemblehdr -save out.exr
   or  ImageStack -loadframes input*.jpg -gamma 0.45 -assemblehdr 1.0 0.5 0.1
                  -save output.exr
<p>
<p>
<p><a name="bidirectionalsimilarity"><h3>bidirectionalsimilarity</h3></a>
<p>
<p>
-bidirectional minimizes bidirectional similarity measure 
based on patchmatch algorithm for acceleration. This is operated
only on the finest scale. The target image is assumed to have
one frame for now.
<p>
 arguments [alpha] [numIter] [numIterPM]
  - alpha : weighting between completeness and coherence term. (default: 0.5)
  - numIter : number of iterations performed. (default: 5)
  - numIterPM : number of iterations performed in PatchMatch. (default: 5)
 You can omit some arguments from right to use default values.
<p>
Usage: ImageStack -load source.jpg -load target.jpg -bidirectional 0.5 -display
<p>
<p>
<p><a name="bilateral"><h3>bilateral</h3></a>
<p>
<p>
-bilateral blurs the top image in the second without crossing boundaries. It
takes up to five arguments: the color standard deviation of the filter, the
standard deviations in width, height, and frames, and the method to use (see
-gausstransform for a description of the methods). If the method is omitted it
automatically chooses an appropriate one. Temporal standard deviation defaults
to zero, and standard deviation in height defaults to the same as the standard
deviation in width
<p>
Usage: ImageStack -load im.jpg -bilateral 0.1 4
<p>
<p><a name="bilateralsharpen"><h3>bilateralsharpen</h3></a>
<p>
<p>
<p>
-bilateralsharpen sharpens using a bilateral filter to avoid ringing. The
three arguments are the spatial and color standard deviations, and the sharpness.
A sharpness of zero has no effect; a sharpness of 1 is significant.
<p>
Usage: ImageStack -load input.jpg -bilateralsharpen 1.0 0.2 1 -save sharp.jpg
<p>
<p>
<p><a name="chromablur"><h3>chromablur</h3></a>
<p>
<p>
<p>
-chromablur blurs an image in the chrominance channels only. It is a good way
of getting rid of chroma noise without apparently blurring the image. The two
arguments are the standard deviation in space and color of the bilateral filter.
Usage: ImageStack -load input.jpg -chromablur 2 -save output.png
<p>
<p>
<p><a name="circularfilter"><h3>circularfilter</h3></a>
<p>
<p>
<p>
-circularfilter convolves the image with a uniform circular kernel. It is a good
approximate to out of focus blur. The sole argument is the radius of the filter.
<p>
Usage: ImageStack -load in.jpg -circularfilter 10 -save out.jpg
<p>
<p>
<p><a name="clamp"><h3>clamp</h3></a>
<p>
<p>
<p>
-clamp restricts the image to be between the given minimum and maximum
by saturating values outside that range. If given no arguments it defaults
to clamping between zero and one.
<p>
Usage: ImageStack -load a.exr -clamp 0 1 -save a.tga
<p>
<p>
<p><a name="colorconvert"><h3>colorconvert</h3></a>
<p>
<p>
<p>
-colorconvert converts from one colorspace to another. It is called with two
arguments representing these colorspaces.
<p>
Allowable colorspaces are rgb, yuv, hsv, xyz, lab and y (luminance alone). grayscale,
gray, and luminance are synonyms for y, and hsb and hsl are synonyms for hsv.
<p>
Usage: ImageStack -load a.tga -colorconvert rgb hsv -scale 0.1 1 1
                  -colorconvert hsv rgb -save out.tga
<p>
<p>
<p><a name="colormatrix"><h3>colormatrix</h3></a>
<p>
<p>
<p>
-colormatrix treats each pixel as a vector over its channels and multiplies
the vector by the given matrix. The matrix size and shape is deduced from the
number of arguments. The matrix is specified in column major order.
<p>
Converting rgb to grayscale:
  ImageStack -load color.tga -colormatrix 1 1 1 -scale 0.33333 -save gray.tga
<p>
Making orange noise:
  ImageStack -push 100 100 1 1 -noise -colormatrix 1 0.3 0 -save noise.tga
<p>
Making noise that varies between orange and blue:
  ImageStack -push 100 100 1 2 -noise -colormatrix 1 0.3 0 0 0 1 -save noise.tga
<p>
<p>
<p><a name="complexconjugate"><h3>complexconjugate</h3></a>
<p>
<p>
-complexconjugate takes a "complex" image, in which the even channels represent
the real component and the odd channels represent the imaginary component, and
produces an image containing the complex conjugate
<p>
Usage: ImageStack -load a.png -fftreal -complexconjugate -display
<p>
<p><a name="complexdivide"><h3>complexdivide</h3></a>
<p>
<p>
-complexdivide divides the top image in the stack by the second image in the
stack, using 2 "complex" images as its input - a "complex" image is one where
channel 2*n is the real part of the nth channel and channel 2*n + 1 is the
imaginary part of the nth channel. Using zero arguments results in a straight
division (a + bi) / (c + di). Using one argument results in a conjugate
division (a - bi) / (c + di).
<p>
Usage: ImageStack -load a.tga -load b.tga -complexdivide -save out.tga.
<p>
<p><a name="compleximag"><h3>compleximag</h3></a>
<p>
<p>
-compleximag takes a "complex" image, in which the even channels represent the
real component and the odd channels represent the imaginary component, and
produces an image containing only the imaginary channels.
<p>
Usage: ImageStack -load a.png -fftreal -compleximag -display
<p>
<p><a name="complexmagnitude"><h3>complexmagnitude</h3></a>
<p>
<p>
-complexmagnitude takes a "complex" image, in which the even channels represent
the real component and the odd channels represent the imaginary component, and
produces an image containing the complex magnitude
<p>
Usage: ImageStack -load a.png -fftreal -complexmagnitude -display
<p>
<p><a name="complexmultiply"><h3>complexmultiply</h3></a>
<p>
<p>
-complexmultiply multiplies the top image in the stack by the second image in
the stack, using 2 "complex" images as its input - a "complex" image is one
where channel 2*n is the real part of the nth channel and channel 2*n + 1 is
the imaginary part of the nth channel. Using zero arguments results in a
straight multiplication (a + bi) * (c + di), using one argument results in a
conjugate multiplication (a - bi) * (c + di).
<p>
Usage: ImageStack -load a.tga -load b.tga -complexmultiply -save out.tga.
<p>
<p><a name="complexphase"><h3>complexphase</h3></a>
<p>
<p>
-complexphase takes a "complex" image, in which the even channels represent the
real component and the odd channels represent the imaginary component, and
produces an image containing the complex phase
<p>
Usage: ImageStack -load a.png -fftreal -complexphase -display
<p>
<p><a name="complexreal"><h3>complexreal</h3></a>
<p>
<p>
-complexreal takes a "complex" image, in which the even channels represent the
real component and the odd channels represent the imaginary component, and
produces an image containing only the real channels.
<p>
Usage: ImageStack -load a.png -fftreal -complexreal -display
<p>
<p><a name="composite"><h3>composite</h3></a>
<p>
<p>
<p>
-composite composites the top image in the stack over the next image in
the stack, using the last channel in the top image in the stack as alpha.
If the top image in the stack has only one channel, it interprets this as
a mask, and composites the second image in the stack over the third image
in the stack using that mask.
<p>
Usage: ImageStack -load a.jpg -load b.jpg -load mask.png -composite
       ImageStack -load a.jpg -load b.jpg -evalchannels [0] [1] [2] \
       "x>width/2" -composite -display
<p>
<p>
<p><a name="convolve"><h3>convolve</h3></a>
<p>
<p>
-convolve takes a width, height, and frames and a single-channel 3D kernel
specified across the rows, then down the columns, then over time, and convolves
the current image by that matrix independently in each channel.
<p>
With no numeric arguments, -convolve will use the next image on the stack as
the filter.
<p>
Boundary conditions can be specified by appending the argument "zero",
"homogeneous", "clamp", or "wrap", which result in the respective assumptions:
the image is zero outside the boundary; the image is weighted with weight one
inside the boundary, and weight zero outside the boundary; the image values
outside the boundary clamp to the nearest defined image value (Neumann); and
the image wraps outside the boundary.
<p>
Convolution by multi-channel filters is poorly defined, because it requires a
vector-vector multiplication between filter values and image values. By
specifying a final argument of "inner", "outer", or "elementwise", the
multiplication used is correspondingly the inner product (or matrix product if
the image and kernel have a differing number of frames); the outer product; or
an elementwise product. If the kernel has k channels and the image has m
channels, "inner" produces an image with max(m/k, k/m) channels, "outer"
produces an image with m*k channels, and "elementwise" requires that m==k and
produces an image with the same number of channels. The default method is
"outer".
<p>
Taking a horizontal gradient with zero boundary condition: 
 ImageStack -load a.tga -convolve 2 1 1  -1 1 zero -save dx.tga
Convolving by a bank of filters: 
 ImageStack -load bank.tmp -load a.tga -convolve homogeneous outer
<p>
<p><a name="createtmp"><h3>createtmp</h3></a>
<p>
<p>
-createtmp creates a zero filled floating point .tmp file of the specified
dimensions. It can be used to create tmp files larger than can fit in memory.
The five arguments are the filename, width, height, frames and channels. If
only four arguments are specified, frames is assumed to be one.
<p>
The following example creates a giant volume, and fills some of it with noise:
ImageStack -createtmp volume.tmp 1024 1024 1024 1 \
           -push 256 256 256 1 -noise \
           -saveblock volume.tmp 512 512 512 0 
<p>
<p>
<p><a name="crop"><h3>crop</h3></a>
<p>
<p>
-crop takes either zero, two, four, or six arguments. The first half of the
arguments are either minimum t, minimum x and y, or all three in the order x,
y, t. The second half of the arguments are correspondingly either number of
frames, width and height, or all three in the order width, height, frames. You
may crop outside the bounds of the original image. Values there are assumed to
be black. If no argument are given, ImageStack guesses how much to crop by
trimming rows and columns that are all the same color as the top left pixel.
<p>
Usage: ImageStack -loadframes f*.tga -crop 10 1 -save frame10.tga
       ImageStack -load a.tga -crop 100 100 200 200 -save cropped.tga
       ImageStack -loadframes f*.tga -crop 100 100 10 200 200 1
                  -save frame10cropped.tga
<p>
<p>
<p><a name="daubechies"><h3>daubechies</h3></a>
<p>
<p>
-daubechies performs the standard 2D daubechies 4 wavelet transform of an image. 
The image size must be a power of two.
<p>
Usage: ImageStack -load in.jpg -daubechies -save out.jpg
<p>
<p>
<p><a name="dct"><h3>dct</h3></a>
<p>
<p>
-dct performs a real discrete cosine transform on the current image, over the
dimensions given in the argument. If no arguments are given, every dimension is
transformed.
<p>
Usage: ImageStack -load a.png -dct xy -save freq.png
<p>
<p><a name="deconvolve"><h3>deconvolve</h3></a>
<p>
<p>
<p>
<p><a name="deinterleave"><h3>deinterleave</h3></a>
<p>
<p>
-deinterleave collects every nth frame, column, and/or row of the image and
tiles the resulting collections. When given two arguments it operates on
columns and rows. When given three arguments, it operates on all columns, rows,
and frames.
<p>
Usage: ImageStack -load lf.exr -deinterleave 16 16 -save lftranspose.exr
<p>
<p>
<p><a name="demosaic"><h3>demosaic</h3></a>
<p>
<p>
<p>
-demosaic demosaics a raw bayer mosaiced image camera. It should be a one
channel image. The algorithm used is adaptive color plane interpolation (ACPI).
Demosaic optionally takes two or three arguments. Two arguments specify an offset
of the standard bayer pattern in x and y. The presence of a third argument
indicates that auto-white-balancing should be performed.
<p>
Usage: ImageStack -load photo.dng -demosaic -save out.png
       ImageStack -load raw.yuv -demosaic 0 1 awb -save out.png
<p>
<p><a name="denan"><h3>denan</h3></a>
<p>
<p>
<p>
-denan replaces all NaN values in the current image with its argument, which
defaults to zero.
<p>
Usage: ImageStack -load in.jpg -eval "1/val" -denan -save out.jpg
<p>
<p>
<p><a name="dimensionreduction"><h3>dimensionreduction</h3></a>
<p>
<p>
-dimensionreduction takes a dimensionality and projects all points on the image
onto a linear subspace of best fit with that number of dimensions. It is useful
if you know an image should be low dimensional (eg a sunset is mostly shades or
red), and components orthogonal to that dimension are unwanted (eg chromatic
abberation).
<p>
Usage: ImageStack -load sunset.jpg -dimensionreduction 2 -save fixed.jpg
<p>
<p>
<p><a name="dimensions"><h3>dimensions</h3></a>
<p>
<p>
-dimensions prints the size of the current image.
<p>
Usage: ImageStack -load a.tga -dimensions
<p>
<p><a name="display"><h3>display</h3></a>
<p>
<p>
<p>
-display opens a window and displays the current image. Subsequent displays
will use the same window. The presence of an optional second argument indicates
that the window should be fullscreen.
<p>
Usage: ImageStack -load a.tga -loop 100 --display --gaussianblur 2
<p>
<p>
<p><a name="divide"><h3>divide</h3></a>
<p>
<p>
<p>
-divide divides the top image in the stack by the second image in the stack.
<p>
Usage: ImageStack -load a.tga -load b.tga -divide -save out.tga.
<p>
<p><a name="downsample"><h3>downsample</h3></a>
<p>
<p>
-downsample divides the width, height, and frames of the current image by the
given integer arguments. It averages rectangles to get the new values.
<p>
-downsample x y is interpreted as -downsample x y 1
-downsample x is interpreted as -downsample x x 1
-downsample is interpreted as -downsample 2 2 1
<p>
Usage: ImageStack -load a.tga -downsample 3 2 -save b.tga
<p>
<p>
<p><a name="dup"><h3>dup</h3></a>
<p>
<p>
<p>
-dup duplicates the current image and pushes it on the stack.
<p>
Usage: ImageStack -load a.tga -dup -scale 0.5 -save a_small.tga
                  -pop -scale 2 -save a_big.tga
<p>
<p>
<p><a name="equalize"><h3>equalize</h3></a>
<p>
<p>
-equalize flattens out the histogram of an image, while preserving ordering
between pixel brightnesses. It does this independently in each channel. When
given no arguments, it produces an image with values between zero and one. With
one argument, it produces values between zero and that argument. With two
arguments, it produces values between the two arguments. The brightest pixel(s)
will always map to the upper bound and the dimmest to the lower bound.
<p>
Usage: ImageStack -load a.tga -equalize 0.2 0.8 -save out.tga
<p>
<p>
<p><a name="eval"><h3>eval</h3></a>
<p>
<p>
<p>
-eval takes a simple expression and evaluates it, writing the result to the
current image.
<p>
Variables:
  x   	 the x coordinate, measured from 0 to width - 1
  y   	 the y coordinate, measured from 0 to height - 1
  t   	 the t coordinate, measured from 0 to frames - 1
  c   	 the current channel
  val 	 the image value at the current x, y, t, c
<p>
Constants:
  e  	 2.71828183
  pi 	 3.14159265
<p>
Uniforms:
  frames 	 the number of frames
  width 	 the image width
  height 	 the image height
  channels 	 the number of channels
Unary Operations:
  -  	 unary negation
<p>
Binary Operations:
  +  	 addition
  -  	 subtraction
  %  	 modulo
  *  	 multiplication
  /  	 division
  ^  	 exponentiation
  >  	 greater than
  <  	 less than
  >= 	 greater than or equal to
  <= 	 less than or equal to
  == 	 equal to
  != 	 not equal to
<p>
Other Operations:
  a ? b : c 	 if a then b else c
  [c]    	 sample the image here on channel c
  [x, y] 	 sample the image with a 3 lobed lanczos filter at X, Y at this channel
  [x, y, t] 	 sample the image with a 3 lobed lanczos filter at X, Y, T at this channel
<p>
Functions:
  log(x)      	 the natural log of x
  exp(x)      	 e to the power of x
  sin(x)      	 the sine of x
  cos(x)      	 the cosine of x
  tan(x)      	 the tangent of x
  asin(x)     	 the inverse sine of x
  acos(x)     	 the inverse cosine of x
  atan(x)     	 the inverse tangent of x
  atan2(y, x) 	 the angle of the vector x, y above horizontal
  abs(x)      	 the absolute value of x
  floor(x)    	 the value of x rounded to the nearest smaller integer
  ceil(x)     	 the value of x rounded to the nearest larger integer
  round(x)    	 the value of x rounded to the nearest integer
  mean()      	 the mean value of the image across all channels
  mean(c)     	 the mean value of the image in channel c
  sum()       	 the sum of the image across all channels
  sum(c)      	 the sum of the image in channel c
  max()       	 the maximum of the image across all channels
  max(c)      	 the maximum of the image in channel c
  min()       	 the minimum of the image across all channels
  min(c)      	 the minimum of the image in channel c
  stddev()    	 the standard deviation of the image across all channels
  stddev(c)   	 the standard deviation of the image in channel c
  variance()  	 the variance of the image across all channels
  variance(c) 	 the variance of the image in channel c
  skew()      	 the skew of the image across all channels
  skew(c)     	 the skew of the image in channel c
  kurtosis()  	 the kurtosis of the image across all channels
  kurtosis(c) 	 the kurtosis of the image in channel c
  covariance(c1, c2) 	 the covariance between channels c1 and c2
<p>
To add more functionality, see Parser.cpp in the source
<p>
Usage: ImageStack -push 128 128 128 1 -eval "(x*y*t)^0.5" -save out.tga
<p>
<p>
<p><a name="evalchannels"><h3>evalchannels</h3></a>
<p>
<p>
<p>
-evalchannels takes some expressions and evaluates them, writing the results
to an image with that many channels.
<p>
Variables:
  x   	 the x coordinate, measured from 0 to width - 1
  y   	 the y coordinate, measured from 0 to height - 1
  t   	 the t coordinate, measured from 0 to frames - 1
  c   	 the current channel
  val 	 the image value at the current x, y, t, c
<p>
Constants:
  e  	 2.71828183
  pi 	 3.14159265
<p>
Uniforms:
  frames 	 the number of frames
  width 	 the image width
  height 	 the image height
  channels 	 the number of channels
Unary Operations:
  -  	 unary negation
<p>
Binary Operations:
  +  	 addition
  -  	 subtraction
  %  	 modulo
  *  	 multiplication
  /  	 division
  ^  	 exponentiation
  >  	 greater than
  <  	 less than
  >= 	 greater than or equal to
  <= 	 less than or equal to
  == 	 equal to
  != 	 not equal to
<p>
Other Operations:
  a ? b : c 	 if a then b else c
  [c]    	 sample the image here on channel c
  [x, y] 	 sample the image with a 3 lobed lanczos filter at X, Y at this channel
  [x, y, t] 	 sample the image with a 3 lobed lanczos filter at X, Y, T at this channel
<p>
Functions:
  log(x)      	 the natural log of x
  exp(x)      	 e to the power of x
  sin(x)      	 the sine of x
  cos(x)      	 the cosine of x
  tan(x)      	 the tangent of x
  asin(x)     	 the inverse sine of x
  acos(x)     	 the inverse cosine of x
  atan(x)     	 the inverse tangent of x
  atan2(y, x) 	 the angle of the vector x, y above horizontal
  abs(x)      	 the absolute value of x
  floor(x)    	 the value of x rounded to the nearest smaller integer
  ceil(x)     	 the value of x rounded to the nearest larger integer
  round(x)    	 the value of x rounded to the nearest integer
  mean()      	 the mean value of the image across all channels
  mean(c)     	 the mean value of the image in channel c
  sum()       	 the sum of the image across all channels
  sum(c)      	 the sum of the image in channel c
  max()       	 the maximum of the image across all channels
  max(c)      	 the maximum of the image in channel c
  min()       	 the minimum of the image across all channels
  min(c)      	 the minimum of the image in channel c
  stddev()    	 the standard deviation of the image across all channels
  stddev(c)   	 the standard deviation of the image in channel c
  variance()  	 the variance of the image across all channels
  variance(c) 	 the variance of the image in channel c
  skew()      	 the skew of the image across all channels
  skew(c)     	 the skew of the image in channel c
  kurtosis()  	 the kurtosis of the image across all channels
  kurtosis(c) 	 the kurtosis of the image in channel c
  covariance(c1, c2) 	 the covariance between channels c1 and c2
<p>
To add more functionality, see Parser.cpp in the source
<p>
Usage: ImageStack -push 128 128 128 1 -evalchannels "[0]*2" "[1]*2 + [0]"
                  -save out.tga
<p>
<p>
<p><a name="exp"><h3>exp</h3></a>
<p>
<p>
<p>
With no arguments -exp calculates e to the current image. With one argument
it calculates that argument to the power of the current image.
<p>
Usage: ImageStack -load a.tga -log -load b.tga -log -add -exp -save product.tga.
<p>
<p><a name="fastblur"><h3>fastblur</h3></a>
<p>
<p>
-fastblur takes a floating point frames, width, and height, and performs a fast
approximate gaussian blur with those standard deviations using the IIR method
of van Vliet et al. If given only two arguments, it performs a blur in x and y
only. If given one argument, it performs the blur in x and y with filter width
the same as height.
<p>
Usage: ImageStack -load in.jpg -fastblur 5 -save blurry.jpg
<p>
<p>
<p><a name="fft"><h3>fft</h3></a>
<p>
<p>
-fft performs a fast dft on the current image, whose values are interpreted as
complex. The input is an image with 2*c channels, where channel 2*i is the real
part of the i'th channel, and channel 2*i+1 is the imaginary part of the i'th
channel. The output image is laid out the same way.
<p>
Usage: ImageStack -load a.tmp -fftcomplex -save freq.tmp
<p>
<p>
<p><a name="fftconvolve"><h3>fftconvolve</h3></a>
<p>
<p>
-fftconvolve performs convolution in Fourier space. It is much faster than
-convolve for large kernels. The two arguments are the boundary condition
(zero, clamp, wrap, homogeneous) and the vector-vector multiplication used
(inner, outer, elementwise). The defaults are wrap and outer respectively. See
-convolve for a description of each option.
<p>
Usage: ImageStack -load filter.tmp -load im.jpg -fftconvolve zero inner
<p>
<p><a name="fftdeconvolve"><h3>fftdeconvolve</h3></a>
<p>
<p>
<p>
-fftdeconvolve uses Fourier-space math to undo a convolution using the gaussian
image prior described in Levin et al. 2007. The convolution specified must be
2D. The arguments are the weight argument (the weight assigned to the gradients
being minimized), then the filter width, filter height, and filter frames, then
the filter to be deconvolved by in row major form. With only the first
argument, fftdeconvolve will use the next image on the stack as the filter. It
must be single channel. The output to deconvolve is constrained to be positive.
<p>
Usage: ImageStack -load filter.png -load in.jpg -deconvolvefast 0.01 -save
dcv.jpg
<p>
<p>
<p><a name="fftpoisson"><h3>fftpoisson</h3></a>
<p>
<p>
-fftpoisson computes an image from a gradient field in the same way as -poisson. It interprets the top image on the stack as the y gradient, and the next image as the x gradient. If a single argument is given, it uses that as a weight, and interprets the third image on the stack as a rough target output. The output of this operation will adhere to the target proportionally to the given weight.
<p>
Usage: ImageStack -load gx.tmp -load gy.tmp -fftpoisson -display
<p>
<p><a name="flip"><h3>flip</h3></a>
<p>
<p>
-flip takes 'x', 'y', or 't' as the argument and flips the current image along
that dimension.
<p>
Usage: ImageStack -load a.tga -flip x -save reversed.tga
<p>
<p>
<p><a name="fprintf"><h3>fprintf</h3></a>
<p>
<p>
-fprintf evaluates and prints its arguments, appending them to the file
specified by the first argument, using the second argument as a format string.
The remaining arguments are all evaluated as floats, so use %d, %i, and other
non-float formats with caution.
<p>
Usage: ImageStack -load foo.jpg -fprintf results.txt "Mean  =  %f" "mean()"
<p>
<p><a name="frametiles"><h3>frametiles</h3></a>
<p>
<p>
<p>
-frametiles takes a volume where each frame is a grid and breaks each frame
into multiple frames, one per grid element. The two arguments specify the grid
size. This operation is the inverse of tileframes.
<p>
Usage: ImageStack -loadframes sheet*.tif -frametiles 5 5 -saveframes frame%d.tif
<p>
<p>
<p><a name="gamma"><h3>gamma</h3></a>
<p>
<p>
<p>
-gamma raise the current image to a power. It can either be called with a single
argument, or with one argument per image channel.
Usage: ImageStack -load a.tga -gamma 0.5 34 2 -save b.tga
<p>
<p>
<p><a name="gaussianblur"><h3>gaussianblur</h3></a>
<p>
<p>
-gaussianblur takes a floating point width, height, and frames, and performs a
gaussian blur with those standard deviations. The blur is performed out to
three standard deviations. If given only two arguments, it performs a blur in x
and y only. If given one argument, it performs the blur in x and y with filter
width the same as height.
<p>
Usage: ImageStack -load in.jpg -gaussianblur 5 -save blurry.jpg
<p>
<p>
<p><a name="gausstransform"><h3>gausstransform</h3></a>
<p>
<p>
-gausstransform replaces each pixel in the top image on the stack with a
Gaussian sum of other "nearby" pixels. Nearby is not defined spatially. Instead
the position of each pixel (in arbitrary-dimensional space) is given by the
second image on the stack. -gausstransform takes one argument to indicate the
method to use, and then one argument per channel in the second image in the
stack to indicate the standard deviation of the desired Gaussian in that
dimension. Methods available are: exact (slow!); grid (the bilateral grid of
Paris et al.); permutohedral (the permutohedral lattice of Adams et al.); and
gkdtree (the gaussian kdtree of Adams et al.). If only one argument is given,
the standard deviations used are all one. If two arguments are given, the
standard deviation is the same in each dimension.
<p>
Usage: ImageStack -load pics/dog1.jpg \
                  -dup -evalchannels x y [0] [1] [2] -pull 1 \
                  -evalchannels [0] [1] [2] 1 \
                  -gausstransform permutohedral 4 4 0.1 0.1 0.1 \
                  -evalchannels [0]/[3] [1]/[3] [2]/[3] \
                  -save bilateral_filtered_dog.jpg
<p>
<p><a name="gradient"><h3>gradient</h3></a>
<p>
<p>
<p>
-gradient takes the backward differences in the dimension specified by the
argument. Values outside the image are assumed to be zero, so the first row,
or column, or frame, will not change, effectively storing the initial value
to make later integration easy. Multiple arguments can be given to differentiate
with respect to multiple dimensions in order (although the order does not matter).
<p>
Warning: Don't expect to differentiate more than twice and be able to get back
the image by integrating. Numerical errors will dominate.
<p>
Usage: ImageStack -load a.tga -gradient x y -save out.tga
<p>
<p>
<p><a name="gradmag"><h3>gradmag</h3></a>
<p>
<p>
-gradmag computes the square gradient magnitude at each pixel in x and
y. Temporal gradients are ignored. The gradient is estimated using
backward differences, and the image is assumed to be zero outside its
bounds.
<p>
Usage: ImageStack -load input.jpg -gradmag -save out.jpg
<p>
<p><a name="haar"><h3>haar</h3></a>
<p>
<p>
-haar performs the standard 2D haar transform of an image. The image size must
be a power of two. If given an integer argument k, it only recurses k times,
and the image size must be a multiple of 2^k.
<p>
Usage: ImageStack -load in.jpg -haar 1 -save out.jpg
<p>
<p>
<p><a name="help"><h3>help</h3></a>
<p>
<p>
ImageStack is a stack language for manipulating images. It is appropriate for
use on the command line and in scripts. Internally, all data is stored as 32
bit floating point, so ImageStack is good for high dynamic range data.
ImageStack is also useful for low dynamic range data, which it treats as values
between 0 and 1.
<p>
-help provides help on a given operation.
Usage: ImageStack -help scale
<p>
Operations available are:
-abs -add -adjoin -affinewarp -align -alignframes -assemblehdr -bidirectionalsimilarity -bilateral -bilateralsharpen -chromablur -circularfilter -clamp -colorconvert -colormatrix -complexconjugate -complexdivide -compleximag -complexmagnitude -complexmultiply -complexphase -complexreal -composite -convolve -createtmp -crop -daubechies -dct -deconvolve -deinterleave -demosaic -denan -dimensionreduction -dimensions -display -divide -downsample -dup -equalize -eval -evalchannels -exp -fastblur -fft -fftconvolve -fftdeconvolve -fftpoisson -flip -fprintf -frametiles -gamma -gaussianblur -gausstransform -gradient -gradmag -haar -help -histogram -histogrammatch -ifft -inpaint -integrate -interleave -inversedaubechies -inversehaar -jointbilateral -kmeans -lahbpcg -lanczosblur -lffocalstack -lfpoint -lfwarp -load -loadarray -loadblock -loadframes -loadpanorama -localmaxima -log -loop -max -medianfilter -min -mod -multiply -nlmeans -noise -normalize -offset -panoramabackground -paste -patchmatch -patchpca -pause -pca -percentilefilter -plot -poisson -pop -printf -pull -push -quantize -realcomplex -receive -rectfilter -resample -reshape -rotate -save -savearray -saveblock -saveframes -scale -send -shuffle -sinugram -sort -statistics -subsample -subtract -threshold -tile -tileframes -time -translate -transpose -upsample -warp -wls 
<p>
<p><a name="histogram"><h3>histogram</h3></a>
<p>
<p>
-histogram displays a per-channel histogram of the current image. The first
optional argument specifies the number of buckets in the histogram. If this is
not given it defaults to 60. The second optional argument specifies a file to
save the histogram to.
<p>
Usage: ImageStack -load a.tga -histogram
<p>
<p><a name="histogrammatch"><h3>histogrammatch</h3></a>
<p>
<p>
-histogrammatch alters the histogram of the current image to match that of the
second image, while preserving ordering. Performing any monotonic operation to
an image, and then histogram matching it to its original should revert it to
its original.
<p>
Usage: ImageStack -load a.tga -load b.tga -histogrammatch -save ba.tga
<p>
<p>
<p><a name="ifft"><h3>ifft</h3></a>
<p>
<p>
-ifft performs an inverse dft on the current image, whose values are complex.
The input and output are images with 2*c channels, where channel 2*i is the
real part of the i'th channel, and channel 2*i+1 is the imaginary part of the
i'th channel.
<p>
Usage: ImageStack -load a.tga -fftcomplex -save freq.tga
<p>
<p>
<p><a name="inpaint"><h3>inpaint</h3></a>
<p>
<p>
<p>
-inpaint takes the image on the top of the stack, and a one channel mask of the
same size second on the stack, and diffuses areas of the image where the mask is
high into areas of the image where the mask is low. Image pixels with mask of 1
are unchanged.
<p>
Usage: ImageStack -push 1 640 480 1 -eval "(X > 0.5)*(X < 0.6)" -load in.jpg
                  -inpaint -save out.jpg
<p>
<p>
<p><a name="integrate"><h3>integrate</h3></a>
<p>
<p>
<p>
-integrate computes partial sums along the given dimension. It is the
of the -gradient operator. Multiply dimensions can be given as arguments,
for example -integrate x y will produce a summed area table of an image.
Allowed dimensions are x, y, or t.
<p>
Warning: Don't expect to integrate more than twice and be able to get back
the image by differentiating. Numerical errors will dominate.
<p>
Usage: ImageStack -load a.tga -gradient x y -integrate y x -save a.tga
<p>
<p>
<p><a name="interleave"><h3>interleave</h3></a>
<p>
<p>
-interleave divides the image into n equally sized volumes and interleaves
them. When given two arguments it operates on columns and rows. When given
three arguments, it operates on columns, rows, and frames.
<p>
Usage: ImageStack -load deck.exr -interleave 2 -save shuffled.exr
<p>
<p>
<p><a name="inversedaubechies"><h3>inversedaubechies</h3></a>
<p>
<p>
-inversedaubechies performs the standard 2D daubechies 4 wavelet transform of an image. 
The image size must be a power of two.
<p>
Usage: ImageStack -load in.jpg -inversedaubechies -save out.jpg
<p>
<p>
<p><a name="inversehaar"><h3>inversehaar</h3></a>
<p>
<p>
-inversehaar inverts the haar transformation with the same argument. See
-help haar for detail.
<p>
<p>
<p><a name="jointbilateral"><h3>jointbilateral</h3></a>
<p>
<p>
-jointbilateral blurs the top image in the second without crossing boundaries
in the second image in the stack. It takes up to five arguments: the color
standard deviation of the filter, the standard deviations in width, height, and
frames, and the method to use (see -gausstransform for a description of the
methods). If the method is omitted it automatically chooses an appropriate one.
Temporal standard deviation defaults to zero, and standard deviation in height
defaults to the same as the standard deviation in width
<p>
Usage: ImageStack -load ref.jpg -load im.jpg -jointbilateral 0.1 4
<p>
<p><a name="kmeans"><h3>kmeans</h3></a>
<p>
<p>
-kmeans clusters the image into a number of clusters given by the single integer argument.
<p>
Usage: ImageStack -load in.jpg -kmeans 3 -save out.jpg
<p>
<p>
<p><a name="lahbpcg"><h3>lahbpcg</h3></a>
<p>
<p>
-lahbpcg takes six images from the stack and treats them as a target output, x
gradient, and y gradient, and then the respective weights for each term. The
weights may be single-channel or have the same number of channels as the target
images. It then attempts to solve for the image which best achieves that target
ouput and those target gradients in the weighted-least-squares sense using a
preconditioned weighted least squares solver. This technique is useful for a
variety of problems with constraints expressed in the gradient domain,
including Poisson solves, making a sparse labelling dense, and other
gradient-domain techniques.
<p>
This operator takes two arguments. The first specifies the maximum number of
iterations, and the second specifies the error required for convergence
<p>
The following example takes a sparse labelling of an image im.jpg, and expands
it to be dense in a manner that respects the boundaries of the image. The
gradient weights used are uniform.
Usage: ImageStack -load sparse_labels.tmp \
                  -load im.jpg -gradient x \
                  -load im.jpg -gradient y \
                  -load sparse_weights.tmp \
                  -push -offset 1 \
                  -dup \
                  -lahbpcg 200 0.001 -save out.png
<p>
<p><a name="lanczosblur"><h3>lanczosblur</h3></a>
<p>
<p>
-lanczosblur convolves the current image by a three lobed lanczos filter. A
lanczos filter is a kind of windowed sinc. The three arguments are filter
width, height, and frames. If two arguments are given, frames is assumed to be
one. If one argument is given, it is interpreted as both width and height.
<p>
Usage: ImageStack -load big.jpg -lanczosblur 2 -subsample 2 2 0 0 -save
small.jpg
<p>
<p>
<p><a name="lffocalstack"><h3>lffocalstack</h3></a>
<p>
<p>
<p>
-lffocalstack turns a 4d light field into a 3d focal stack. The five arguments
are the lenslet width, height, the minimum alpha, the maximum alpha, and the
step size between adjacent depths (alpha is slope in line space).
<p>
Usage: ImageStack -load lf.exr -lffocalstack 16 16 -1 1 0.1 -display
<p>
<p>
<p><a name="lfpoint"><h3>lfpoint</h3></a>
<p>
<p>
<p>
-lfpoint colors a single 3d point white in the given light field. The five
arguments are the light field u, v, resolution, and then the x, y, and z
coordinates of the point. x and y should be in the range [0, 1], while z
is disparity. z = 0 will be at the focal plane.
<p>
Usage: ImageStack -load lf.exr -lfpoint 16 16 0.5 0.5 0.1 -save newlf.exr
<p>
<p>
<p><a name="lfwarp"><h3>lfwarp</h3></a>
<p>
<p>
<p>
-lfwarp treats the top image of the stack as indices (within [0, 1]) into the
lightfield represented by the second image, and samples quadrilinearly into it.
The two arguments it takes are the width and height of each lenslet.
The number of channels in the top image has to be 4, with the channels being
the s,t,u and v coordinates in that order.
An extra argument of 'quick' at the end switches nearest neighbor resampling on
Usage: ImageStack -load lf.jpg -load lfmap.png -lfwarp 8 8 -save out.jpg
<p>
<p>
<p><a name="load"><h3>load</h3></a>
<p>
<p>
-load loads a file and places it on the top of the stack. ImageStack can load
the following file formats:
<p>
.tmp files. This format is used to save temporary image data, and to
interoperate with other programs that can load or save raw binary data. The
format supports any number of frames and channels. A .tmp file starts with a
header that containining five 32-bit integer values which represents frames,
width, height, channels and type. Image data follows.
types:
 0: 32 bit floats (the default format, which matches the internal format)
 1: 64 bit doubles
 2: 8 bit unsigned integers
 3: 8 bit signed integers
 4: 16 bit unsigned integers
 5: 16 bit signed integers
 6: 32 bit unsigned integers
 7: 32 bit signed integers
 8: 64 bit unsigned integers
 9: 64 bit signed integers
<p>
When saving, an optional second argument specifies the format. This may be any
of int8, uint8, int16, uint16, int32, uint32, int64, uint64, float32, float64,
or correspondingly char, unsigned char, short, unsigned short, int, unsigned
int, float, or double. The default is float32.
<p>
.hdr files. These always have three channels and one frame. They store data
in a 4 bytes per pixel red green blue exponent (rgbe) format.
<p>
.jpg (or .jpeg) files. When saving, an optional second arguments specifies
the quality. This defaults to 90. A jpeg image always has a single frame,
and may have either one or three channels.
<p>
.png files. These have a bit depth of 8, and may have 1-4 channels. They may
only have 1 frame.
<p>
.ppm files, of either 8 or 16 bit depth. When saving, an optional second
argument, which defaults to 8, specifies the bit depth. ppm files always
have three channels and one frame.
<p>
.tga files. These can have 1, 3, or 4 channels, are run-length encoded, and
are low dynamic range.
<p>
.tiff (or .tif or .meg) files. When saving, an optional second argument
specifies the format. This may be any of int8, uint8, int16, uint16, int32,
uint32, float16, float32, float64, or correspondingly char, unsigned char,
short, unsigned short, int, unsigned int, half, float, or double. The default
is uint16.
<p>
.wav sound files. They are represented as one or two channel images with
height and width of 1, but many frames.
<p>
.flo files. This format is used for optical flow evaluation. It stores 2-band
float image for horizontal and vertical flow components.
<p>
.csv files. These contain comma-separated floating point values in text. Each
scanline of the image corresponds to a line in the file. x and c are thus
conflated, as are y and t. When loading csv files, ImageStack assumes 1 channel
and 1 frame.
<p>
Usage: ImageStack -load foo.jpg
<p>
<p>
<p><a name="loadarray"><h3>loadarray</h3></a>
<p>
<p>
-loadarray loads raw arrays of various data types. It takes 6 arguments. The
first is the filename to be loaded, the second is the data type, which must be
one of: int8, uint8, int16, uint16, int32, uint32, float32, float64, or
equivalently: char, unsigned char, short, unsigned short, int, unsigned int,
float, double. The last four arguments specify the dimensions in the order
width, height, frames, and channels. Bear in mind that ImageStack stores values
internally as 32 bits floats, so information will be lost when double arrays
are loaded. Integer formats are not scaled to lie between zero and one, this
must be done manually with the -scale operation.
<p>
Usage: ImageStack -loadarray foo.bar uint8 640 480 1 3
<p>
<p>
<p><a name="loadblock"><h3>loadblock</h3></a>
<p>
<p>
-loadblock loads a rectangular portion of a .tmp file. It is roughly equivalent
to a load followed by a crop, except that the file need not fit in memory. The
nine arguments are filename, x, y, t, and c offsets within the file, then
width, height, frames, and channels. If seven arguments are given, all channels
are loaded. If five arguments are given, all frames are used and the arguments
specify x and y. If three arguments are given, they specify frames and all x,
y, and channels are loaded. Loading out of bounds from the tmp file is
permitted. Undefined areas will be zero-filled.
<p>
This example multiplies a 512x512x128x3 volume by two, without ever loading it
all into memory:
ImageStack -loadblock foo.tmp 0 0 0 0 512 512 64 3 \
           -scale 2 -saveblock foo.tmp 0 0 0 0
ImageStack -loadblock foo.tmp 0 0 0 64 512 512 64 3 \
           -scale 2 -saveblock foo.tmp 0 0 64 0
<p>
<p>
<p><a name="loadframes"><h3>loadframes</h3></a>
<p>
<p>
<p>
-loadframes accepts a sequence of images and loads them as the frames of a
single stack entry. See the help for -load for details on file formats.
<p>
-loadframes cannot be used on raw float files. To achieve the same effect, cat
the files together and load them as a single multi-frame image.
<p>
Usage: ImageStack -loadframes foo*.jpg bar*.png
<p>
<p>
<p><a name="loadpanorama"><h3>loadpanorama</h3></a>
<p>
<p>
<p>
-loadpanorama takes a filename as its first argument. The file must be the
homography text file output from autostitch. It loads and parses this file, 
and places each warped image in a separate frame. The remaining six arguments
specify minimum and maximum theta, then phi, then the desired output resolution.
<p>
Usage: ImageStack -loadpanorama pano.txt -0.1 0.1 -0.1 0.1 640 480 -display
<p>
<p>
<p><a name="localmaxima"><h3>localmaxima</h3></a>
<p>
<p>
-localmaxima finds local maxima in the image and outputs their locations to a
text file. Each line in the text file consists of four comma-delimited floating
point values, corresponding to the t, x and y coordinates, and the strength of
the local maxima (its value minus the maximum neighbor). -localmaxima will only
operate on the first channel of an image. There are three arguments. The first
is some string containing the characters x, y, and t. It specifies the
dimensions over which a pixel must be greater than its neighbors. The second is
the minimum value by which a pixel must exceed its neighbors to count as a
local maximum. The third is the minimum distance which must separate adjacent
local maxima.
<p>
Usage: ImageStack -load stack.tmp -localmaxima txy 0.01 5 output.txt
<p>
<p><a name="log"><h3>log</h3></a>
<p>
<p>
<p>
-log takes the natural log of the current image.
<p>
Usage: ImageStack -load a.tga -log -load b.tga -log -add -exp -save product.tga.
<p>
<p><a name="loop"><h3>loop</h3></a>
<p>
<p>
<p>
-loop takes an integer and a sequence of commands, and loops that sequence
the specified number of times. The commands that form the argument must be
prefixed with an extra dash. It is possible to nest this operation using more
dashes. If given no integer argument, loop will loop forever.
<p>
Usage: ImageStack -load a.tga -loop 36 --rotate 10 --loop 10 ---downsample
                  ---upsample -save b.tga
<p>
<p>
<p><a name="max"><h3>max</h3></a>
<p>
<p>
<p>
-max replaces the top image in the stack with the max of the top two images.
<p>
Usage: ImageStack -load a.tga -load b.tga -max -save out.tga.
<p>
<p><a name="medianfilter"><h3>medianfilter</h3></a>
<p>
<p>
-medianfilter applies a median filter with a circular support. The sole argument is
the pixel radius of the filter.
<p>
Usage: ImageStack -load input.jpg -median 10 -save output.jpg
<p>
<p>
<p><a name="min"><h3>min</h3></a>
<p>
<p>
<p>
-min replaces the top image in the stack with the min of the top two images.
<p>
Usage: ImageStack -load a.tga -load b.tga -min -save out.tga.
<p>
<p><a name="mod"><h3>mod</h3></a>
<p>
<p>
<p>
-mod takes the floating point modulus of the current image. It can either be
called with a single argument, or with one argument per image channel.
Usage: ImageStack -load a.tga -mod 0.5 34 2 -save b.tga
<p>
<p>
<p><a name="multiply"><h3>multiply</h3></a>
<p>
<p>
<p>
-multiply multiplies the top image in the stack by the second image in the stack.
<p>
Usage: ImageStack -load a.tga -load b.tga -multiply -save out.tga.
<p>
<p><a name="nlmeans"><h3>nlmeans</h3></a>
<p>
<p>
-nlmeans denoises an image using non-local means, by performing a PCA reduction
on Gaussian weighted patches and then doing a joint-bilateral filter of the
image with respect to those PCA-reduced patches. The four arguments required
are the standard deviation of the Gaussian patches used, the number of
dimensions to reduce the patches to, the spatial standard deviation of the
filter, and the patch-space standard deviation of the filter. Tolga Tasdizen
demonstrates in "Principal Components for Non-Local Means Image Denoising" that
6 dimensions work best most of the time. You can optionally add a fifth
argument that specifies which method to use for the joint bilateral filter (see
-gausstransform).
<p>
Usage: ImageStack -load noisy.jpg -nlmeans 1.0 6 50 0.02
<p>
<p><a name="noise"><h3>noise</h3></a>
<p>
<p>
-noise adds uniform noise to the current image, uncorrelated across the
channels, in the range between the two arguments. With one argument, the lower
value is assumed to be zero. With no arguments, the range is assumed to be [0,
1]
<p>
Usage: ImageStack -load a.tga -push -noise -add -save anoisy.tga
<p>
<p>
<p><a name="normalize"><h3>normalize</h3></a>
<p>
<p>
<p>
-normalize restricts the image to be between 0 and 1
by rescaling and shifting it.
<p>
Usage: ImageStack -load a.exr -normalize -save a.tga
<p>
<p>
<p><a name="offset"><h3>offset</h3></a>
<p>
<p>
<p>
-offset adds to the current image. It can either be called with a single
argument, or with one argument per image channel.
Usage: ImageStack -load a.tga -offset 0.5 34 2 -save b.tga
<p>
<p>
<p><a name="panoramabackground"><h3>panoramabackground</h3></a>
<p>
<p>
<p>
-panoramabackground takes aligned frames and computes what lies behind any
objects that move across the frames.
<p>
Usage: ImageStack -loadpanorama pano.txt -panoramabackground -display
<p>
<p>
<p><a name="paste"><h3>paste</h3></a>
<p>
<p>
-paste places some of the second image in the stack inside the top image, at
the specified location. -paste accepts two or three, six, or nine arguments.
When given two or three arguments, it interprets these as x and y, or x, y,
and t, and pastes the whole of the second image onto that location in the first
image. If six or nine arguments are given, the latter four or six arguments
specify what portion of the second image is copied. The middle two or three
arguments specify the top left, and the last two or three arguments specify
the size of the region to paste.
<p>
The format is thus: -paste [desination origin] [source origin] [size]
<p>
Usage: ImageStack -load a.jpg -push 820 820 1 3 -paste 10 10 -save border.jpg
<p>
<p>
<p><a name="patchmatch"><h3>patchmatch</h3></a>
<p>
<p>
-patchmatch computes approximate nearest neighbor field from the top
image on the stack to the second image on the stack, using the
algorithm from the PatchMatch SIGGRAPH 2009 paper. This operation
requires two input images which may have multiple frames.
It returns an image with four channels. First three channels 
correspond to x, y, t coordinate of closest patch and 
fourth channels contains the sum of squared differences 
between patches. 
<p>
 arguments [numIter] [patchSize]
  - numIter : number of iterations performed. (default: 5)
  - patchSize : size of patch. (default: 7, 7x7 square patch)
 You can omit some arguments from right to use default values.
<p>
Usage: ImageStack -load target.jpg -load source.jpg -patchmatch -save match.tmp
<p>
<p>
<p><a name="patchpca"><h3>patchpca</h3></a>
<p>
<p>
-patchpca treats local Gaussian neighbourhoods of pixel values as vectors and
performs pca on them to reduce dimensionality. The resulting vectors are stored
at each pixel over the color channels. The two arguments are the standard
deviation of the Gaussian, and the desired number of output dimensions. Patches
near the edge of the image are not included in the covariance computation, but
are transformed along with the rest of the pixels.
<p>
Usage: ImageStack -load a.jpg -patchpca 2 8 -save pca.tmp
<p>
<p><a name="pause"><h3>pause</h3></a>
<p>
<p>
<p>
-pause waits for the user to press hit enter.
<p>
Usage: ImageStack -load a.tga -display -pause -load b.tga -display
<p>
<p>
<p><a name="pca"><h3>pca</h3></a>
<p>
<p>
-pca reduces the number of channels in the image to the given parameter, using
principal components analysis (PCA).
<p>
Usage: ImageStack -load a.jpg -pca 1 -save gray.png
<p>
<p><a name="percentilefilter"><h3>percentilefilter</h3></a>
<p>
<p>
-percentilefilter selects a given statistical percentile over a circular support
around each pixel. The two arguments are the support radius, and the percentile.
A percentile argument of 0.5 gives a median filter, whereas 0 or 1 give min or
max filters.
<p>
Usage: ImageStack -load input.jpg -percentilefilter 10 0.25 -save dark.jpg
<p>
<p>
<p><a name="plot"><h3>plot</h3></a>
<p>
<p>
<p>
-plot takes images with height 1 and range [0, 1], and graphs them.
It takes three arguments: the width and height of the resulting graph,
and the line thickness to use for the plot. The resulting graph will
have the same number of frames and channels as the input.
<p>
<p>
<p><a name="poisson"><h3>poisson</h3></a>
<p>
<p>
-poisson assumes the stack contains gradients images in x and y, and attempts
to find the image which fits those gradients best in a least squares sense. It
uses a preconditioned conjugate gradient descent method. It takes one argument,
which is required RMS error of the result. This defaults to 0.01 if not given.
<p>
Usage: ImageStack -load dx.tmp dy.tmp 
                  -poisson 0.0001 -save out.tga
<p>
<p>
<p><a name="pop"><h3>pop</h3></a>
<p>
<p>
<p>
-pop removes the top image from the stack
<p>
Usage: ImageStack -load a.tga -load b.tga -save b.gif -pop -save a.gif
<p>
<p>
<p><a name="printf"><h3>printf</h3></a>
<p>
<p>
-printf evaluates and prints its arguments, using the first argument as a
format string. The remaining arguments are all evaluated as floats, so use %d,
%i, and other non-float formats with caution.
<p>
Usage: ImageStack -load foo.jpg -printf "Mean  =  %f" "mean()"
<p>
<p>
<p><a name="pull"><h3>pull</h3></a>
<p>
<p>
<p>
-pull brings a buried stack element to the top. -pull 0 does nothing. -pull 1
brings up the second stack element, and so on.
<p>
Usage: ImageStack -load a.tga -load b.tga -save b.gif -pull 1 -save a.gif
<p>
<p>
<p><a name="push"><h3>push</h3></a>
<p>
<p>
-push adds a new zeroed image to the top of the stack. With no arguments it matches the dimensions of the current image. With 4 arguments (width, height, frames, and channels) it creates an image of that size. Given three arguments frames defaults to 1, and the arguments are taken as width, height, and channels.
<p>
Usage: ImageStack -load a.tga -push -add -scale 0.5 -multiply -save out.tga
       ImageStack -push 1024 1024 1 3 -offset 0.5 -save gray.tga
<p>
<p>
<p><a name="quantize"><h3>quantize</h3></a>
<p>
<p>
<p>
-quantize rounds all values down to the nearest multiple of the sole
argument. If no argument is given, quantize rounds down to the nearest
integer.
<p>
Usage: ImageStack -load test.jpg -quantize 1/128 -save test2.jpg
<p>
<p>
<p><a name="realcomplex"><h3>realcomplex</h3></a>
<p>
<p>
-realcomplex takes a "real" image, and converts it to a "complex" image, in
which the even channels represent the real component and the odd channels
represent the imaginary component.
<p>
Usage: ImageStack -load a.png -realcomplex -fft -display
<p>
<p><a name="receive"><h3>receive</h3></a>
<p>
<p>
<p>
-receive sets up a TCP server and listens for an image (such as that sent by
-send). The sole optional argument is the port to listen on. It defaults
to 5678.
<p>
Usage: ImageStack -receive 5243 -save image.jpg
<p>
       ImageStack -loop --receive --scale 2 --send somewhereelse
<p>
<p>
<p><a name="rectfilter"><h3>rectfilter</h3></a>
<p>
<p>
-rectfilter performs a iterated rectangular filter on the image. The four
arguments are the filter width, height, frames, and the number of iterations.
If three arguments are given, they are interpreted as frames, width, and
height, and the number of iterations is assumed to be one. If two arguments are
given they are taken as width and height, and frames is assumed to be one. If
one argument is given it is taken as both width and height, with frames and
iterations again assumed to be one.
<p>
Usage: ImageStack -load in.jpg -rectfilter 1 10 10 -save out.jpg
<p>
<p>
<p><a name="resample"><h3>resample</h3></a>
<p>
<p>
-resample resamples the input using a 3-lobed Lanczos filter. When given three arguments, it produces a new volume of the given width, height, and frames. When given two arguments, it produces a new volume of the given width and height, with the same number of frames.
<p>
Usage: ImageStack -loadframes f*.tga -resample 20 50 50 -saveframes f%03d.tga
<p>
<p>
<p><a name="reshape"><h3>reshape</h3></a>
<p>
<p>
<p>
-reshape changes the way the memory of the current image is indexed. The four
integer arguments specify a new width, height, frames, and channels.
<p>
Usage: ImageStack -load movie.tmp -reshape width height*frames 1 channels
                  -save filmstrip.tmp
<p>
<p><a name="rotate"><h3>rotate</h3></a>
<p>
<p>
<p>
-rotate takes a number of degrees, and rotates every frame of the current image
clockwise by that angle. The rotation preserves the image size, filling empty
 areas with zeros, and throwing away data which will not fit in the bounds.
<p>
Usage: ImageStack -load a.tga -rotate 45 -save b.tga
<p>
<p>
<p><a name="save"><h3>save</h3></a>
<p>
<p>
<p>
-save stores the image at the top of the stack to a file. The stack is not
altered. The following file formats are supported:
<p>
<p>
.tmp files. This format is used to save temporary image data, and to
interoperate with other programs that can load or save raw binary data. The
format supports any number of frames and channels. A .tmp file starts with a
header that containining five 32-bit integer values which represents frames,
width, height, channels and type. Image data follows.
types:
 0: 32 bit floats (the default format, which matches the internal format)
 1: 64 bit doubles
 2: 8 bit unsigned integers
 3: 8 bit signed integers
 4: 16 bit unsigned integers
 5: 16 bit signed integers
 6: 32 bit unsigned integers
 7: 32 bit signed integers
 8: 64 bit unsigned integers
 9: 64 bit signed integers
<p>
When saving, an optional second argument specifies the format. This may be any
of int8, uint8, int16, uint16, int32, uint32, int64, uint64, float32, float64,
or correspondingly char, unsigned char, short, unsigned short, int, unsigned
int, float, or double. The default is float32.
<p>
.hdr files. These always have three channels and one frame. They store data
in a 4 bytes per pixel red green blue exponent (rgbe) format.
<p>
.jpg (or .jpeg) files. When saving, an optional second arguments specifies
the quality. This defaults to 90. A jpeg image always has a single frame,
and may have either one or three channels.
<p>
.png files. These have a bit depth of 8, and may have 1-4 channels. They may
only have 1 frame.
<p>
.ppm files, of either 8 or 16 bit depth. When saving, an optional second
argument, which defaults to 8, specifies the bit depth. ppm files always
have three channels and one frame.
<p>
.tga files. These can have 1, 3, or 4 channels, are run-length encoded, and
are low dynamic range.
<p>
.wav sound files. They are represented as one or two channel images with
height and width of 1, but many frames.
<p>
.tiff (or .tif or .meg) files. When saving, an optional second argument
specifies the format. This may be any of int8, uint8, int16, uint16, int32,
uint32, float16, float32, float64, or correspondingly char, unsigned char,
short, unsigned short, int, unsigned int, half, float, or double. The default
is uint16.
<p>
.flo files. This format is used for optical flow evaluation. It stores 2-band
float image for horizontal and vertical flow components.
<p>
.csv files. These contain comma-separated floating point values in text. Each
scanline of the image corresponds to a line in the file. x and c are thus
conflated, as are y and t. When loading csv files, ImageStack assumes 1 channel
and 1 frame.
<p>
Usage: ImageStack -load in.ppm -save out.jpg 98
       ImageStack -load in.ppm -save out.jpg
       ImageStack -load in.ppm -save out.ppm 16
<p>
<p>
<p><a name="savearray"><h3>savearray</h3></a>
<p>
<p>
-savearray saves raw arrays of various data types. It takes 2 arguments. The first
is the filename to be loaded, the second is the data type, which must be one of:
int8, uint8, int16, uint16, int32, uint32, float32, float64, or equivalently:
char, unsigned char, short, unsigned short, int, unsigned int, float, double.
<p>
Bear in mind that ImageStack stores values internally as 32 bit floats, so
saving in double format does not give you higher fidelity.
<p>
Integer type formats are not scaled from the range zero to one. This must be
done manually using the -scale operation.
<p>
Usage: ImageStack -load in.jpg -savearray out.float float32
<p>
<p>
<p><a name="saveblock"><h3>saveblock</h3></a>
<p>
<p>
-saveblock overwrites a rectangular subblock of a .tmp file with the top of the
stack. It is logically similar to a load, paste, save combination, but never
loads the full tmp file. The five arguments are the filename, followed by the
offset at which to paste the volume in x, y, t, and c. When given four
arguments c is assumed to be zero. When given three arguments t is also set to
zero. With two arguments, x, y, and c are set to zero.
<p>
This example multiplies a 128x512x512x3 volume by two, without ever loading it
all into memory:
ImageStack -loadblock foo.tmp 0 0 0 0 64 512 512 3 \
           -scale 2 -saveblock foo.tmp 0 0 0 0
ImageStack -loadblock foo.tmp 64 0 0 0 64 512 512 3 \
           -scale 2 -saveblock foo.tmp 0 0 0 0
<p>
<p>
<p><a name="saveframes"><h3>saveframes</h3></a>
<p>
<p>
<p>
-saveframes takes a printf style format argument, and saves all the frames in
the current image as separate files. See the help for save for details on file
formats.
<p>
Usage: ImageStack -loadframes *.jpg -saveframes frame%03d.png
       ImageStack -loadframes *.jpg -saveframes frame%03d.ppm 16
<p>
<p>
<p><a name="scale"><h3>scale</h3></a>
<p>
<p>
<p>
-scale scales the current image. It can either be called with a single
argument, or with one argument per image channel.
Usage: ImageStack -load a.tga -scale 0.5 34 2 -save b.tga
<p>
<p>
<p><a name="send"><h3>send</h3></a>
<p>
<p>
<p>
-send sends an image over a TCP connection. It has an optional first and second
argument.  The first argument specifies which server to contact, and the second
argument specifies the port. By default, 127.0.0.1:5678 is used.
<p>
Usage: ImageStack -load a.tga -remotedisplay localhost 5678
<p>
<p><a name="shuffle"><h3>shuffle</h3></a>
<p>
<p>
-shuffle takes every pixel in the current image and swaps it to a random new
location creating a new noise image with exactly the same histogram.
<p>
Usage: ImageStack -load a.tga -shuffle -save shuffled.tga
<p>
<p>
<p><a name="sinugram"><h3>sinugram</h3></a>
<p>
<p>
<p>
<p><a name="sort"><h3>sort</h3></a>
<p>
<p>
-sort sorts the data along the given dimension for every value of the other
dimensions. For example, the following command computes the median frame of a
video.
<p>
ImageStack -loadframes frame*.jpg -sort t -crop frames/2 1 -save median.jpg
<p>
<p>
<p><a name="statistics"><h3>statistics</h3></a>
<p>
<p>
-statistics provides per channel statistical information about the current
image.
<p>
Usage: ImageStack -load a.tga -statistics
<p>
<p><a name="subsample"><h3>subsample</h3></a>
<p>
<p>
<p>
-subsample subsamples the current image. Given two integer arguments, a and b,
it selects one out of every a frames starting from frame b. Given four arguments,
a, b, c, d, it selects one pixel out of every axb sized box, starting from pixel
(c, d). Given six arguments, a, b, c, d, e, f, it selects one pixel from every
axbxc volume, in the order width, height, frames starting at pixel (d, e, f).
<p>
Usage: ImageStack -load in.jpg -subsample 2 2 0 0 -save smaller.jpg
<p>
<p>
<p><a name="subtract"><h3>subtract</h3></a>
<p>
<p>
<p>
-subtract subtracts the second image in the stack from the top image in the stack.
<p>
Usage: ImageStack -load a.tga -load b.tga -subtract -save out.tga.
<p>
<p><a name="threshold"><h3>threshold</h3></a>
<p>
<p>
<p>
-threshold sets the image to zero where it is less than the argument, and
sets it to one where it is greater than or equal to the argument.
<p>
Usage: ImageStack -load a.exr -threshold 0.5 -save monochrome.tga
<p>
<p>
<p><a name="tile"><h3>tile</h3></a>
<p>
<p>
<p>
-tile repeats the image along each dimension. It interprets two arguments as
repetitions in x and y. Three arguments are interpreted as repetitions in x,
y, and t.
<p>
Usage: ImageStack -load a.tga -tile 2 2 -save b.tga
<p>
<p>
<p><a name="tileframes"><h3>tileframes</h3></a>
<p>
<p>
<p>
-tileframes takes a volume and lays down groups of frames in a grid, dividing
the number of frames by the product of the arguments. It takes two arguments,
the number of old frames across each new frame, and the number of frames down.
each new frame. The first batch of frames will appear as the first row of the.
first frame of the new volume.
<p>
Usage: ImageStack -loadframes frame*.tif -tileframes 5 5 -saveframes sheet%d.tif
<p>
<p>
<p><a name="time"><h3>time</h3></a>
<p>
<p>
<p>
-time takes a sequence of commands, performs that sequence, and reports how
long it took. The commands that form the argument must be prefixed with an extra
dash. If given to arguments, it simply reports the time since the program was
launched. It is a useful operation for profiling.
<p>
Usage: ImageStack -load a.jpg -time --resample 10 10 --scale 2
<p>
<p>
<p><a name="translate"><h3>translate</h3></a>
<p>
<p>
<p>
-translate moves the image data, leaving black borders. It takes two or three
arguments. Two arguments are interpreted as a shift in x and a shift in y. Three
arguments indicates a shift in t, x, and y. Negative values shift to the top left
and positive ones to the bottom right. The unit is pixels.
<p>
Usage: ImageStack -load in.jpg -translate -10 -10 -translate 20 20
                  -translate -10 -10 -save in_border.jpg
<p>
<p>
<p><a name="transpose"><h3>transpose</h3></a>
<p>
<p>
-transpose takes two dimension of the form 'x', 'y', or 't' and transposes
the current image over those dimensions. If given no arguments, it defaults
to x and y.
<p>
Usage: ImageStack -load a.tga -transpose x y -flip x -save rotated.tga
<p>
<p>
<p><a name="upsample"><h3>upsample</h3></a>
<p>
<p>
-upsample multiplies the width, height, and frames of the current image by the
given integer arguments. It uses nearest neighbor interpolation. For a slower,
high-quality resampling method, use -resample instead.
<p>
-upsample x y is interpreted as -upsample x y 1
-upsample x is interpreted as -upsample x x 1
-upsample is interpreted as -upsample 2 2 1
<p>
Usage: ImageStack -load a.tga -upsample 3 2 -save b.tga
<p>
<p>
<p><a name="warp"><h3>warp</h3></a>
<p>
<p>
<p>
-warp treats the top image of the stack as indices (within [0, 1]) into the
second image, and samples the second image accordingly. It takes no arguments.
The number of channels in the top image is the dimensionality of the warp, and
should be three or less.
<p>
Usage: ImageStack -load in.jpg -push -evalchannels "X+Y" "Y" -warp -save out.jpg
<p>
<p>
<p><a name="wls"><h3>wls</h3></a>
<p>
<p>
-wls filters the image with the wls-filter described in the paper
Edge-Preserving Decompositions for Multi-Scale Tone and Detail Manipulation by
Farbman et al. The first parameter (alpha) controls the sensitivity to edges,
and the second one (lambda) controls the amount of smoothing.
<p>
Usage: ImageStack -load in.jpg -wls 1.2 0.25 -save blurry.jpg
<p>
</td></tr></body></html>
